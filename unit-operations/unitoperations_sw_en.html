<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.542">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Biofoundry Workflows</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Biofoundry Workflows</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../workflows.html"> 
<span class="menu-text">Workflows</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-unit-operations" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Unit Operations</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-unit-operations">    
        <li>
    <a class="dropdown-item" href="../unit-operations-hw.html">
 <span class="dropdown-text">Hardware</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../unit-operations-sw.html">
 <span class="dropdown-text">Software</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sblabkribb/biofoundry_workflows"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#unit-operations" id="toc-unit-operations" class="nav-link active" data-scroll-target="#unit-operations"><span class="header-section-number">1</span> Unit-operations</a>
  <ul class="collapse">
  <li><a href="#software" id="toc-software" class="nav-link" data-scroll-target="#software"><span class="header-section-number">1.1</span> Software</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<pre><code>Title: Biofoundry Unit-operations for software
Description: Collection of standardized Unit-operations
Version: 0.3.2
Language: English
Suggestions:
  - https://github.com/sblabkribb/biofoundry_workflows/issues
Last updated: 2025-08-15
Categories:
  - unit-operations
  - biofoundry
  - lab automation
  - software</code></pre>
<section id="unit-operations" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Unit-operations</h1>
<section id="software" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="software"><span class="header-section-number">1.1</span> Software</h2>
<ul>
<li><strong>USW005</strong>: Biological Database
<ul>
<li><strong>Software</strong>: https://registry.igem.org/, Partbank, https://synbiohub.org/, https://bioparts.org/</li>
<li><strong>Description</strong>: Retrieving and utilizing standardized biological parts from curated databases for use in downstream applications. This operation enables users to search, filter, and select genetic elements such as promoters, coding DNA sequences (CDS), and terminators, ensuring compatibility and adherence to established design standards in assembly and characterization.</li>
</ul></li>
<li><strong>USW010</strong>: DNA Oligomer Pool Design
<ul>
<li><strong>Software</strong>: Dsembler, DNAWorks</li>
<li><strong>Description</strong>: A software package that designs DNA oligomers which are pooled in a single tube. It optimizes the selection and combination of oligomers for efficient DNA assembly and synthesis.</li>
</ul></li>
<li><strong>USW020</strong>: Primer Design
<ul>
<li><strong>Software</strong>: SnapGene, Primer3, OligoAnalyzer</li>
<li><strong>Description</strong>: Designing primers regarding melting temperature and structure. The primers are used for mutant generation, PCR primers, and other molecular biology applications, ensuring specificity and efficiency in amplification.</li>
</ul></li>
<li><strong>USW030</strong>: Vector Design
<ul>
<li><strong>Software</strong>: VectorNTI, SnapGene, Geneious</li>
<li><strong>Description</strong>: Designing vector maps regarding inserts and a plasmid backbone. This might include primer design and DNA assembly processes, facilitating the construction of functional genetic vectors for cloning and expression.</li>
</ul></li>
<li><strong>USW040</strong>: Sequence Optimization
<ul>
<li><strong>Software</strong>: GeneOptimizer, JCat</li>
<li><strong>Description</strong>: Modifying codon usage of a DNA sequence to maximize protein expression in a specific host. This software ensures optimal translation efficiency and protein yield by adapting sequences to host-specific codon preferences.</li>
</ul></li>
<li><strong>USW050</strong>: Synthesis Screening
<ul>
<li><strong>Software</strong>: UltraSEQ, Common Mechanism, FAST-NA</li>
<li><strong>Description</strong>: Tools for screening potentially dangerous DNA sequences. These tools help ensure biosafety by identifying sequences that may pose risks in synthetic biology applications.</li>
</ul></li>
<li><strong>USW060</strong>: Structure-based Sequence Generation
<ul>
<li><strong>Software</strong>: ProteinMPNN</li>
<li><strong>Description</strong>: Generating sequences based on protein structures using AI models. This software aids in designing novel proteins with desired structural and functional properties.</li>
</ul></li>
<li><strong>USW070</strong>: Protein Structure Prediction
<ul>
<li><strong>Software</strong>: Alphafold, Rosettafold, I-TASSER</li>
<li><strong>Description</strong>: Predicting protein structures using AI models. These tools provide insights into protein folding and stability, supporting protein engineering and drug discovery efforts.</li>
</ul></li>
<li><strong>USW080</strong>: Protein Structure Generation
<ul>
<li><strong>Software</strong>: RFdiffusion</li>
<li><strong>Description</strong>: Generating protein structures using AI models. This software facilitates the design of new proteins and enzymes with specific catalytic or binding functions.</li>
</ul></li>
<li><strong>USW090</strong>: Retrosynthetic Pathway Design
<ul>
<li><strong>Software</strong>: RetroPath2.0, ECREACT, BioNavi-NP</li>
<li><strong>Description</strong>: To predict biosynthetic pathways using tools for checking reaction feasibilities and for novel pathway discovery. These tools support metabolic engineering by identifying efficient routes for chemical synthesis.</li>
</ul></li>
<li><strong>USW100</strong>: Enzyme Identification
<ul>
<li><strong>Software</strong>: DeepEC, Selenzyme, SoluProt</li>
<li><strong>Description</strong>: To search for enzymes from databases or to predict enzyme properties such as reactivities for selecting proper enzymes in pathways. This software aids in enzyme discovery and characterization for biocatalysis.</li>
</ul></li>
<li><strong>USW110</strong>: Sequence Alignment
<ul>
<li><strong>Software</strong>: BLAST, MUSCLE, Clustalw, Omega</li>
<li><strong>Description</strong>: Exploring and comparing sequence similarity using alignment algorithms. These tools are essential for identifying homologous sequences and understanding evolutionary relationships.</li>
</ul></li>
<li><strong>USW120</strong>: Sequence Trimming and Filtering
<ul>
<li><strong>Software</strong>: Trimmomatic, Cutadapt, Porechop, Filtlong</li>
<li><strong>Description</strong>: Preprocessing for removing low-quality long/short-read sequences. This step is crucial for ensuring data quality in sequencing projects.</li>
</ul></li>
<li><strong>USW130</strong>: Read Mapping and Alignment
<ul>
<li><strong>Software</strong>: BWA, Bowtie2, Minimap2, GraphMap</li>
<li><strong>Description</strong>: Mapping long/short-read sequences to reference sequences. These tools are used for genome assembly, variant calling, and transcriptomics.</li>
</ul></li>
<li><strong>USW140</strong>: Sequence Assembly
<ul>
<li><strong>Software</strong>: Velvet, SOAP, Quast, Canu, Flye</li>
<li><strong>Description</strong>: Assembling long/short-read sequences for complete gene, pathway, and chromosome. This software supports the reconstruction of genomes and metagenomes.</li>
</ul></li>
<li><strong>USW145</strong>: Metagenomic Assembly
<ul>
<li><strong>Software</strong>: MetaSPAdes, MEGAHIT</li>
<li><strong>Description</strong>: Assembling metagenomic data to reconstruct genomes from complex microbial communities. This software supports environmental and clinical metagenomics studies.</li>
</ul></li>
<li><strong>USW150</strong>: Sequence Quality Control
<ul>
<li><strong>Software</strong>: FastQC, MultiQC, NanoPlot, pycoQC</li>
<li><strong>Description</strong>: Performing quality control (QC) on long/short-read fastq and fast5 files. QC is essential for identifying and correcting errors in sequencing data.</li>
</ul></li>
<li><strong>USW160</strong>: Demultiplexing
<ul>
<li><strong>Software</strong>: bcl-convert, Guppy</li>
<li><strong>Description</strong>: Separating NGS reads based on native or user-defined barcodes. This process is critical for handling multiplexed sequencing data.</li>
</ul></li>
<li><strong>USW170</strong>: Variant Calling
<ul>
<li><strong>Software</strong>: GATK, bcftools, Sniffles, Longshot</li>
<li><strong>Description</strong>: Detecting variants based on read mapping. These tools are used for identifying SNPs, indels, and structural variants in genomic data.</li>
</ul></li>
<li><strong>USW180</strong>: RNA-Seq Analysis
<ul>
<li><strong>Software</strong>: DESeq2/EdgeR (R), Galaxy, HISAT2</li>
<li><strong>Description</strong>: Processing and analyzing transcriptomic data to quantify gene expression levels, identify splice variants, and detect differential gene expression. This software supports functional genomics studies.</li>
</ul></li>
<li><strong>USW185</strong>: Gene Set Enrichment Analysis
<ul>
<li><strong>Software</strong>: GSEA, DAVID</li>
<li><strong>Description</strong>: Analyzing gene expression data to identify enriched biological pathways. This software supports functional genomics and systems biology research.</li>
</ul></li>
<li><strong>USW190</strong>: Proteomics Data Analysis
<ul>
<li><strong>Software</strong>: MaxQuant, Perseus, Proteome Discoverer</li>
<li><strong>Description</strong>: Processing and interpreting data from mass spectrometry to identify and quantify proteins, understand modifications, and assess protein interactions. These tools are essential for proteomics research.</li>
</ul></li>
<li><strong>USW200</strong>: Phylogenetic Analysis
<ul>
<li><strong>Software</strong>: MEGA, PhyML</li>
<li><strong>Description</strong>: Determining the evolutionary relationships among species or sequences by constructing phylogenetic trees based on sequence similarities and differences. This software supports evolutionary biology studies.</li>
</ul></li>
<li><strong>USW210</strong>: Metabolic Flux Analysis
<ul>
<li><strong>Software</strong>: COBRA Toolbox, FBA, CellNetAnalyzer</li>
<li><strong>Description</strong>: Modeling and analyzing metabolic pathways, providing insights into cellular metabolism and pathway optimization. These tools are used for metabolic engineering and systems biology.</li>
</ul></li>
<li><strong>USW220</strong>: Deep Learning Data Preparation
<ul>
<li><strong>Software</strong>: pytorch::DataLoader, Huggingface::datasets</li>
<li><strong>Description</strong>: Preparing and batching datasets for AI model training and evaluation. This software supports machine learning workflows in bioinformatics.</li>
</ul></li>
<li><strong>USW230</strong>: Sequence Embedding
<ul>
<li><strong>Software</strong>: ProtT5, ProtBERT, ESM</li>
<li><strong>Description</strong>: Biological sequence embedding procedure. This process is used for transforming sequences into numerical representations for machine learning applications.</li>
</ul></li>
<li><strong>USW240</strong>: Deep Learning Model Training
<ul>
<li><strong>Software</strong>: CNN, LSTM, Transformer, Bayesian opt.</li>
<li><strong>Description</strong>: Model training procedure using training data. This software supports the development of AI models for various bioinformatics tasks.</li>
</ul></li>
<li><strong>USW250</strong>: Model Evaluation
<ul>
<li><strong>Software</strong>: scikit-learn, TensorBoard</li>
<li><strong>Description</strong>: Utilizing model evaluation metrics (accuracy, precision, recall, F1 score, etc.). This software is used for assessing the performance of machine learning models.</li>
</ul></li>
<li><strong>USW260</strong>: Hyperparameter Tuning
<ul>
<li><strong>Software</strong>: Optuna, HyperOpt</li>
<li><strong>Description</strong>: Efficiently exploring the search space using Bayesian optimization techniques. This software supports the optimization of machine learning models.</li>
</ul></li>
<li><strong>USW270</strong>: Model Deployment
<ul>
<li><strong>Software</strong>: TorchScript, FastAPI</li>
<li><strong>Description</strong>: Deploying trained models as services. This software supports the integration of AI models into production environments.</li>
</ul></li>
<li><strong>USW280</strong>: Monitoring and Reporting
<ul>
<li><strong>Software</strong>: Prometheus, Grafana</li>
<li><strong>Description</strong>: Monitoring and visualizing performance and resource usage of AI models. This software supports the maintenance and optimization of deployed models.</li>
</ul></li>
<li><strong>USW290</strong>: Phenotype Data Preprocessing
<ul>
<li><strong>Software</strong>: R, Python</li>
<li><strong>Description</strong>: Preprocessing measured and collected phenotype data. It involves cleaning, organizing, and transforming raw phenotype datasets for downstream analysis.</li>
</ul></li>
<li><strong>USW300</strong>: XCMS Analysis
<ul>
<li><strong>Software</strong>: XCMS (R)</li>
<li><strong>Description</strong>: Analyzing and visualizing chromatographically separated and single-spectra mass spectral data. This software supports metabolomics research.</li>
</ul></li>
<li><strong>USW310</strong>: Flow Cytometry Analysis
<ul>
<li><strong>Software</strong>: flowcore, flowworkspace (R), flowJo</li>
<li><strong>Description</strong>: Analyzing and visualizing flow cytometry data. This software supports immunology and cell biology research.</li>
</ul></li>
<li><strong>USW320</strong>: DNA Assembly Simulation
<ul>
<li><strong>Software</strong>: pyDNA (python)</li>
<li><strong>Description</strong>: Simulating DNA assembly such as Golden Gate and Gibson for increasing assembly success rate. This software supports synthetic biology and genetic engineering.</li>
</ul></li>
<li><strong>USW325</strong>: Gene Editing Simulation
<ul>
<li><strong>Software</strong>: CRISPResso, CHOPCHOP</li>
<li><strong>Description</strong>: Simulating gene editing outcomes using CRISPR technology. This software helps predict off-target effects and optimize guide RNA design for precise genome editing.</li>
</ul></li>
<li><strong>USW330</strong>: Well Plate Mapping
<ul>
<li><strong>Software</strong>: Well plate mapping software</li>
<li><strong>Description</strong>: Software for mapping well plate source plates to destination plates. This tool supports high-throughput screening and assay development.</li>
</ul></li>
<li><strong>USW340</strong>: Computation
<ul>
<li><strong>Software</strong>: Computer</li>
<li><strong>Description</strong>: A general process of data collection, preprocessing, and analysis steps. This software supports a wide range of bioinformatics and computational biology applications.</li>
</ul></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>